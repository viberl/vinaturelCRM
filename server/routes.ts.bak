import { Express, Request, Response, NextFunction, json } from "express";
import { createServer, Server as HttpServer } from "http";
import { Server as SocketIOServer, Socket } from "socket.io";
import { storage } from "./storage";
import { insertCustomerSchema, insertInteractionSchema } from "@shared/schema";
import cors from "cors";
import dotenv from "dotenv";
import { 
  loginCustomer, 
  getCurrentCustomer, 
  logoutCustomer, 
  LoginResponse, 
  CustomerData 
} from "./shopware";
import { auth, AuthRequest, generateToken } from "./auth";

// Load environment variables
dotenv.config();

// Ensure required environment variables are set
if (!process.env.JWT_SECRET) {
  console.warn('WARNUNG: JWT_SECRET ist nicht gesetzt. Verwende Standardwert.');
}

if (!process.env.SHOPWARE_URL) {
  throw new Error('SHOPWARE_URL muss in der .env Datei gesetzt sein');
}

if (!process.env.SHOPWARE_ACCESS_KEY) {
  throw new Error('SHOPWARE_ACCESS_KEY muss in der .env Datei gesetzt sein');
}

if (!process.env.CLIENT_URL) {
  console.warn('WARNUNG: CLIENT_URL ist nicht gesetzt. Verwende Standardwert.');
}

export async function registerRoutes(app: Express): Promise<HttpServer> {
  // Enable CORS
  app.use(cors({
    origin: process.env.CLIENT_URL || 'http://localhost:3000',
    credentials: true
  }));

  // Parse JSON bodies
  app.use(json());

  // Auth routes - support both /api/login and /api/auth/login for compatibility
  const handleLogin = async (req: Request, res: Response) => {
    console.log('Login request received:', { 
      headers: req.headers,
      body: { ...req.body, password: req.body.password ? '***' : undefined },
      ip: req.ip,
      method: req.method,
      url: req.originalUrl,
      timestamp: new Date().toISOString()
    });
    
    try {
      const { email, password } = req.body;
      
      // Validate request body
      if (!email || !password) {
        console.log('Missing email or password');
        return res.status(400).json({ 
          success: false, 
          message: 'E-Mail und Passwort werden benötigt',
          code: 'MISSING_CREDENTIALS',
          timestamp: new Date().toISOString()
        });
      }

      // Login to Shopware
      console.log('Attempting to login to Shopware...');
      let loginResponse;
      try {
        loginResponse = await loginCustomer(email, password);
        console.log('Shopware login successful, context token received');
      } catch (shopwareError: any) {
        console.error('Shopware login error:', {
          message: shopwareError.message,
          status: shopwareError.status,
          response: shopwareError.response?.data,
          stack: shopwareError.stack
        });
        
        // Handle specific Shopware errors
        if (shopwareError.status === 401) {
          return res.status(401).json({
            success: false,
            message: 'Ungültige Anmeldedaten. Bitte überprüfen Sie E-Mail und Passwort.',
            code: 'INVALID_CREDENTIALS',
            timestamp: new Date().toISOString()
          });
        }
        
        // Handle network errors
        if (shopwareError.code === 'ECONNREFUSED' || shopwareError.code === 'ENOTFOUND') {
          return res.status(503).json({
            success: false,
            message: 'Verbindung zum Server fehlgeschlagen. Bitte versuchen Sie es später erneut.',
            code: 'SERVICE_UNAVAILABLE',
            timestamp: new Date().toISOString()
          });
        }
        
        // Handle timeout
        if (shopwareError.code === 'ETIMEDOUT' || shopwareError.code === 'ECONNABORTED') {
          return res.status(504).json({
            success: false,
            message: 'Verbindung zum Server hat zu lange gedauert. Bitte versuchen Sie es später erneut.',
            code: 'GATEWAY_TIMEOUT',
            timestamp: new Date().toISOString()
          });
        }
        
        // For other errors, return a generic error
        return res.status(500).json({
          success: false,
          message: 'Ein unerwarteter Fehler ist aufgetreten. Bitte versuchen Sie es später erneut.',
          code: 'INTERNAL_SERVER_ERROR',
          timestamp: new Date().toISOString()
        });
      }
      
      // Get customer data
      console.log('Fetching customer data...');
      let customer;
      try {
        customer = await getCurrentCustomer(loginResponse.contextToken);
        console.log('Customer data received:', { 
          id: customer.id, 
          email: customer.email,
          group: customer.group?.name,
          timestamp: new Date().toISOString()
        });
      } catch (customerError: any) {
        console.error('Error fetching customer data:', {
          message: customerError.message,
          status: customerError.status,
          response: customerError.response,
          stack: customerError.stack,
          timestamp: new Date().toISOString()
        });
        
        // Handle specific customer data errors
        if (customerError.status === 401) {
          return res.status(401).json({
            success: false,
            message: 'Ihre Sitzung ist abgelaufen. Bitte melden Sie sich erneut an.',
            code: 'SESSION_EXPIRED',
            timestamp: new Date().toISOString()
          });
        }
        
        return res.status(500).json({
          success: false,
          message: 'Fehler beim Laden der Benutzerdaten. Bitte versuchen Sie es später erneut.',
          code: 'CUSTOMER_DATA_ERROR',
          timestamp: new Date().toISOString()
        });
      }

      // Check if user is a sales rep
      const isSalesRep = customer.group?.name === 'Außendienstmitarbeiter';
      
      if (!isSalesRep) {
        console.log('Access denied: User is not a sales rep', { 
          userId: customer.id, 
          email: customer.email,
          group: customer.group?.name,
          timestamp: new Date().toISOString()
        });
        
        return res.status(403).json({
          success: false,
          message: 'Zugriff verweigert. Sie benötigen Verkäuferrechte.',
          code: 'ACCESS_DENIED',
          timestamp: new Date().toISOString()
        });
      }

      // Generate JWT token using the helper function
      console.log('Generating JWT token...');
      let token;
      try {
        const tokenData = {
          id: customer.id,
          email: customer.email,
          firstName: customer.firstName,
          lastName: customer.lastName,
          customerNumber: customer.customerNumber,
          role: 'sales_rep',
          contextToken: loginResponse.contextToken,
          timestamp: new Date().toISOString()
        };
        
        console.log('Creating JWT token with data:', {
          ...tokenData,
          contextToken: '***REDACTED***'
        });
        
        token = generateToken(tokenData);
        
        console.log('JWT token generated successfully', {
          userId: customer.id,
          tokenLength: token?.length || 0,
          timestamp: new Date().toISOString()
        });
      } catch (tokenError: any) {
        console.error('Error generating JWT token:', {
          message: tokenError.message,
          stack: tokenError.stack,
          timestamp: new Date().toISOString()
        });
        
        return res.status(500).json({
          success: false,
          message: 'Interner Serverfehler. Bitte versuchen Sie es später erneut.',
          code: 'TOKEN_GENERATION_ERROR',
          timestamp: new Date().toISOString()
        });
      }

      console.log('Login successful, preparing response', {
        userId: customer.id,
        email: customer.email,
        timestamp: new Date().toISOString()
      });
      
      // Prepare user data for response
      const userData = {
        id: customer.id,
        email: customer.email,
        firstName: customer.firstName,
        lastName: customer.lastName,
        customerNumber: customer.customerNumber,
        role: 'sales_rep',
        contextToken: loginResponse.contextToken
      };
      
      // Log the response (without sensitive data)
      console.log('Sending login response', {
        success: true,
        user: {
          ...userData,
          contextToken: '***REDACTED***'
        },
        token: token ? '***JWT_TOKEN***' : 'MISSING',
        timestamp: new Date().toISOString()
      });
      
      // Set response headers
      res.setHeader('Content-Type', 'application/json');
      res.setHeader('Cache-Control', 'no-store');
      res.setHeader('Pragma', 'no-cache');
      
      // Return token and user data
      return res.status(200).json({
        success: true,
        token,
        user: userData
      });
      
    } catch (error: any) {
      const timestamp = new Date().toISOString();
      const errorId = `err_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
      
      // Log the full error with request details
      console.error('Unexpected login error:', {
        errorId,
        timestamp,
        message: error.message,
        name: error.name,
        code: error.code,
        status: error.status,
        statusCode: error.statusCode,
        response: error.response,
        request: {
          method: req.method,
          url: req.originalUrl,
          headers: req.headers,
          body: { 
            ...req.body, 
            password: req.body.password ? '***REDACTED***' : undefined 
          },
          query: req.query,
          params: req.params,
          ip: req.ip,
          ips: req.ips,
          hostname: req.hostname,
          protocol: req.protocol,
          secure: req.secure,
          subdomains: req.subdomains
        },
        stack: error.stack
      });
      
      // Determine status code
      let statusCode = 500;
      if (error.status && typeof error.status === 'number') {
        statusCode = error.status;
      } else if (error.statusCode && typeof error.statusCode === 'number') {
        statusCode = error.statusCode;
      } else if (error.response?.status) {
        statusCode = error.response.status;
      }
      
      // Determine error message
      let errorMessage = 'Ein unerwarteter Fehler ist aufgetreten';
      if (error.message) {
        errorMessage = error.message;
      } else if (error.response?.data?.message) {
        errorMessage = error.response.data.message;
      } else if (error.response?.data?.errors?.[0]?.detail) {
        errorMessage = error.response.data.errors[0].detail;
      }
      
      // Determine error code
      let errorCode = 'UNKNOWN_ERROR';
      if (error.code) {
        errorCode = error.code;
      } else if (error.response?.data?.code) {
        errorCode = error.response.data.code;
      } else if (error.response?.data?.errors?.[0]?.code) {
        errorCode = error.response.data.errors[0].code;
      }
      
      // Send error response
      return res.status(statusCode).json({
        success: false,
        message: errorMessage,
        code: errorCode,
        errorId,
      timestamp,
      headers: req.headers,
      ip: req.ip
    });
    
    try {
      if (req.user?.contextToken) {
        console.log('Logging out user with context token', {
          userId: req.user.id,
          tokenPrefix: req.user.contextToken ? `${req.user.contextToken.substring(0, 10)}...` : 'MISSING',
          timestamp
        });
        
        const logoutSuccess = await logoutCustomer(req.user.contextToken);
        
        if (!logoutSuccess) {
          console.warn('Logout may not have been fully processed on the Shopware side', {
            userId: req.user.id,
            timestamp
          });
        }
      } else {
        console.log('No context token found for user, skipping Shopware logout', {
          userId: req.user?.id,
          timestamp
        });
      }
      
      // Clear any client-side tokens
      res.setHeader('Clear-Site-Data', '"cookies", "storage"');
      
      console.log('Logout successful', {
        userId: req.user?.id,
        timestamp
      });
      
      return res.status(200).json({ 
        success: true, 
        message: 'Erfolgreich abgemeldet',
        timestamp
      });
      
    } catch (error: any) {
      console.error('Logout error:', {
        errorId,
        message: error.message,
        stack: error.stack,
        userId: req.user?.id,
        timestamp
      });
      
      // Even if logout fails, we still want to clear the client-side session
      res.setHeader('Clear-Site-Data', '"cookies", "storage"');
      
      return res.status(500).json({ 
        success: false, 
        message: 'Fehler beim Abmelden. Ihre Sitzung wurde lokal gelöscht, aber möglicherweise nicht auf dem Server.',
        code: 'LOGOUT_ERROR',
        errorId,
        timestamp
      });
    }
  });

  // Get current user
  app.get('/api/auth/me', auth, async (req: AuthRequest, res: Response) => {
    const timestamp = new Date().toISOString();
    const errorId = `err_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
    
    console.log('Me request received', {
      userId: req.user?.id,
      timestamp,
      headers: req.headers,
      ip: req.ip
    });
    
    try {
      if (!req.user) {
        console.warn('Unauthorized access to /api/auth/me', { 
          timestamp,
          headers: req.headers,
          ip: req.ip
        });
        
        return res.status(401).json({ 
          success: false, 
          message: 'Nicht autorisiert',
          code: 'UNAUTHORIZED',
          errorId,
          timestamp
        });
      }
      
      // Log successful response (without sensitive data)
      console.log('Returning user data', {
        userId: req.user.id,
        email: req.user.email,
        role: req.user.role,
        timestamp
      });
      
      return res.status(200).json({ 
        success: true, 
        user: {
          id: req.user.id,
          email: req.user.email,
          firstName: req.user.firstName,
          lastName: req.user.lastName,
          customerNumber: req.user.customerNumber,
          role: req.user.role,
          // Don't send context token to client in /me response
        },
        timestamp
      });
      
    } catch (error: any) {
      console.error('Error in /api/auth/me:', {
        errorId,
        message: error.message,
        stack: error.stack,
        userId: req.user?.id,
        timestamp
      });
      
      return res.status(500).json({ 
        success: false, 
        message: 'Fehler beim Abrufen der Benutzerdaten',
        code: 'USER_DATA_ERROR',
        errorId,
        timestamp
      });
    }
  });

  // Create HTTP server and Socket.IO instance
  const httpServer = createServer(app);
  
  // Configure CORS for Socket.IO
  const corsOptions = {
    origin: (origin: string | undefined, callback: (err: Error | null, success?: boolean) => void) => {
      // Allow connections with no origin (like mobile apps or curl requests)
      if (!origin) return callback(null, true);
      
      const allowedOrigins = [
        'http://localhost:3000',
        'http://localhost:3001',
        'http://127.0.0.1:3000',
        'http://127.0.0.1:3001',
        'https://www.vinaturel.de',
        'https://vinaturel.de',
        ...(process.env.CLIENT_URL ? [process.env.CLIENT_URL] : []),
        ...(process.env.SHOPWARE_URL ? [process.env.SHOPWARE_URL] : [])
      ];
      
      const isAllowed = allowedOrigins.some(allowed => 
        origin === allowed || 
        origin.startsWith(allowed) ||
        (origin.startsWith('http://localhost:') || origin.startsWith('https://localhost:')) ||
        (origin.startsWith('http://127.0.0.1:') || origin.startsWith('https://127.0.0.1:'))
      );
      
      if (isAllowed) {
        console.log('Socket.IO connection allowed from origin:', origin);
        return callback(null, true);
      } else {
        console.warn('Socket.IO connection blocked from origin:', origin);
        return callback(new Error('Not allowed by CORS'));
      }
    },
    methods: ['GET', 'POST'],
    credentials: true,
    allowedHeaders: ['Content-Type', 'Authorization'],
    exposedHeaders: ['Content-Type', 'Authorization']
  };
  
  const io = new SocketIOServer(httpServer, {
    cors: corsOptions,
    path: '/socket.io/',
    serveClient: false,
    connectTimeout: 10000,
    pingTimeout: 5000,
    pingInterval: 25000
  });

  // Socket.IO connection handling with authentication and error handling
  io.on('connection', (socket: Socket) => {
    const clientId = socket.id;
    const clientIp = socket.handshake.address;
    const userAgent = socket.handshake.headers['user-agent'] || 'unknown';
    const timestamp = new Date().toISOString();
    
    console.log('New client connected', {
      clientId,
      clientIp,
      userAgent,
      query: socket.handshake.query,
      timestamp
    });
    
    // Authentication middleware
    const token = socket.handshake.auth.token || 
                 socket.handshake.query.token ||
                 (socket.handshake.headers.authorization || '').split(' ')[1];
    
    if (!token) {
      console.warn('Client connected without authentication token', { clientId, timestamp });
      socket.emit('unauthorized', { 
        success: false, 
        message: 'Authentication token is required',
        timestamp
      });
      return socket.disconnect(true);
    }
    
    // TODO: Verify JWT token here if needed
    // try {
    //   const decoded = verifyToken(token);
    //   socket.data.user = decoded;
    // } catch (error) {
    //   console.warn('Invalid authentication token', { clientId, error, timestamp });
    //   socket.emit('unauthorized', { 
    //     success: false, 
    //     message: 'Invalid or expired token',
    //     timestamp
    //   });
    //   return socket.disconnect(true);
    // }
    
    // Log successful authentication
    console.log('Client authenticated', { 
      clientId, 
      // userId: socket.data.user?.id,
      timestamp 
    });
    
    // Handle disconnection
    socket.on('disconnect', (reason) => {
      console.log('Client disconnected', { 
        clientId, 
        // userId: socket.data.user?.id, 
        reason,
        timestamp: new Date().toISOString() 
      });
    });
    
    // Handle errors
    socket.on('error', (error) => {
      console.error('Socket error', { 
        clientId, 
        // userId: socket.data.user?.id, 
        error: error.message,
        stack: error.stack,
        timestamp: new Date().toISOString() 
      });
    });
  });
  
  // Handle Socket.IO server errors
  io.engine.on('connection_error', (err) => {
    console.error('Socket.IO connection error:', {
      message: err.message,
      code: err.code,
      context: err.context,
      timestamp: new Date().toISOString()
    });
  });

  return httpServer;
}
